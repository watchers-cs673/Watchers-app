# User data

The database uses MongoDB interfacing via [Prisma](https://www.prisma.io/), an ORM interface which generates code to interact with databases programatically. This greatly simplifies coding of database operations, and allows a relational model to be defined even though MongoDB is a NoSQL database. Hence, the benefits of MongoDB performance can be used alongside the benefits of a relational model and its ease of usage with regards to programming paradigms. MongoDB is also beneficial in that it is performant at scale.

## Usage

### Prequisites

In the repository root directory (the git directory containing the entire project), make sure your repo is up to date with `git fetch`, then `git status` to check.

If your git is up to date then run `npm install` in the repository root directory.

Make sure you have installed MongoDB, you can follow the directions [here](https://www.mongodb.com/docs/manual/administration/install-community/).

### Setup (this only needs to be done once per machine/server)

#### Setup MongoDB

In your terminal, run the command `mongod` (this is the MongoDB background process). Alternatively, if you installed via Homebrew (on macOS) run `brew services start mongodb-community`.

#### Setup the .env file

Create a file in the `watchers-app/` directory, named `.env`.

Run `mongosh` in the terminal and note the URL it provides, which should begin with `mongodb://`.

Within it, add the following text:

```env
DATABASE_URL="<mongodb url here>"
```

Where `<mongodb url here>` is replaced by the MongoDB URL you just copied.

#### Initialize Prisma

Run `npx prisma db push` to generate the client and database automatically in MongoDB.

## User profile data concept

MongoDB is chosen as a NoSQL database. Using the JSON model of data access, it is easy to program with and use while remaining performant at scale.

The user data contains the following components:

- user unique ID
- username
- email
- password hash
- display name

The user posts data are in another collection differentiated using the unique ID

- post type (profile-post)
  - user unique ID
  - post unique ID
  - post text content
  - referenced movie unique ID
  - post likes:
    - user account likes (unique ID list)
  - post comments (only relevant if profile-post):
    - each comment body contains
      - commenting user unique ID
      - comment unique ID
      - comment text content
      - comment likes:
      - user account likes (unique ID list)

The full layout of the user data can be seen in the schematic file, [schema.prisma](../../prisma/schema.prisma).

## Valid new user creation requirements

A new user MUST have a unique email, username, and unique ID. The email and username are chosen upon registration, and if either is present already in the database, the registration is prevented and an error is returned. The user may retry with a different email or username. Unique ID meanwhile, is an internal value generated by the database, so with each new user is guaranteed to be unique.

## User authentication

We use a password which is stored in a hashed format generated by [bcrypt](https://www.npmjs.com/package/bcrypt), as [storing passwords in plaintext is known to be insecure](https://security.stackexchange.com/questions/36833/why-should-i-hash-passwords).

Security requires checking user token on each post, and fetching the user ID from the database rather than caching in browser. This is slightly less performant, but more secure.

### an approach to generating an auth token

An approach considered was to generate a unique salt value for each user upon registration, (a kind of "private key"), based on registration time with a suitable crypto-safe random number generator, then store this in the database. This would use the combination of this hidden value and the login time to generate a session token using bcrypt. Store the most recent login time in the database server-side and in the browser cookie client-side (option: allow one or multiple logins i.e. multiple devices). The browser client sends the user token and login time value to the server which checks the cached login time to regenerate a user token with its stored hidden user salt value, then compares this with the value sent by the browser client. If these match, this is considered a successful authentication; appropriate user actions can be allowed. The usage of login time as a variable also allows expiry of tokens, upon which re-login is required. Manual logout also flushes token from browser client and server database.

The Auth0 library also provides similar functionality, although it limits the number of users that may login at one time depending on the plan paid for.

The [jsonwebtoken](https://www.npmjs.com/package/jsonwebtoken) library can be used to generate a user token.

<!-- We could store the user token in the database, and also store multiple time-sensitive tokens in order to allow multiple device use. Time of token creation could be stored with each token in the database. -->

Finally, as JSON Web Tokens are a widely supported authentication token protocol it was decided to use this to create authentication tokens for users and authenticate them.

This is also compatible with Auth0 and other services.

## User/Posts/Comments ID

Unique IDs results from [ObjectID](https://www.mongodb.com/docs/manual/reference/method/ObjectId/) in MongoDB which are provided by default.

## TODO/future goals

- The unique IDs could be created in a manner similar to the [Snowflake ID](https://en.wikipedia.org/wiki/Snowflake_ID) used by Twitter.
  - The snowflake ID is used to dynamically generate the user registration time deterministically yet in a manner that scales. This is also used for posts and comments.
- add media embeds to posts
- implement generation of unique IDs
- expand beyond movies
- consider performance of comment loading mechanism
- do we want to store comments separately? (separate comments and posts e.g. Instagram/Facebook etc) or display comments are also posts i.e. blur boundary between comments and posts (e.g. Twitter)
- consider security of login/hash or use Auth0 or another authentication service
- implement a security requirement to assess passwords for strength based on properties of common words and presence of non-alphabetic characters, etc
- impose the length maximum for username and check for secure password
<!-- - Use MongoDB or another NoSQL database for scalability -->
